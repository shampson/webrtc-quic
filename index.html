<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>QUIC API for WebRTC</title>
  <script class="remove" src="respec-w3c-common.js" type="text/javascript"></script>
  <script src="respec-config.js" class="remove"></script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a set of ECMAScript APIs in WebIDL to allow data to be sent
    and received from another browser or device implementing the QUIC
    protocol. This specification is being developed in conjunction with a protocol
    specification developed by the IETF QUIC Working Group.</p>
  </section>
  <section id="sotd">
    <p>The API is based on preliminary work done in the W3C ORTC Community Group.</p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>This specification extends the WebRTC specification [[!WEBRTC]] to
    enable the use of QUIC [[!QUIC-TRANSPORT]] to exchange arbitrary data with
    remote peers using NAT-traversal technologies such as ICE, STUN, and
    TURN. Since QUIC can be multiplexed on the same port as RTP, RTCP,
    DTLS, STUN and TURN, this specification is compatible with all the
    functionality defined in [[!WEBRTC]], including communication
    using audio/video media and SCTP data channels.</p>
    <p>While this specification defines an interface to QUIC streams,
    by utilizing a QUIC stream per message, it is possible to implement
    support for message-based communications (such as <code>RTCDataChannel</code>)
    on top.  While the QUIC transport defined in [[!QUIC-TRANSPORT]] is reliable,
    support for unreliable communications is achievable via use of timers or
    through extensions to the QUIC protocol.</p>
  </section>
  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL-1]], as
    this specification uses that specification and terminology.</p>
  </section>
  <section>
    <h2>Terminology</h2>
     <p>The <code><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
      interface, representing a callback used for event handlers, and the <a href=
      "http://dev.w3.org/html5/spec/webappapis.html#errorevent"><code><dfn>ErrorEvent</dfn></code></a>
      interface are defined in [[!HTML51]].</p>
      <p>The concepts <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a></dfn>,
      <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a simple
      event</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#networking-task-source">networking
      task source</a></dfn> are defined in [[!HTML51]].</p>
      <p>The terms <dfn>event</dfn>, <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
      handlers</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
      handler event types</a></dfn> are defined in [[!HTML51]].</p>
     <p>When referring to exceptions, the terms <dfn><a
      href="https://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a></dfn> and
      <dfn data-dfn-for="exception"><a href=
      "https://www.w3.org/TR/WebIDL-1/#dfn-create-exception">create</a></dfn> are
      defined in [[!WEBIDL-1]].</p>
      <p>The terms <dfn data-lt="fulfill|fulfillment">fulfilled</dfn>, <dfn
      data-lt="reject|rejection|rejecting">rejected</dfn>,
      <dfn data-lt="resolve|resolves">resolved</dfn>, <dfn>pending</dfn> and
      <dfn>settled</dfn> used in the context of Promises are defined in
      [[!ECMASCRIPT-6.0]].</p>
      <p>The <dfn><code>RTCIceTransport</code></dfn> and <dfn><code>RTCCertificate</code></dfn> interfaces
      and the <dfn><code>RTCDtlsFingerprint</code></dfn> dictionary are defined in [[!WEBRTC]].</p>
  </section>
  <section id="quic-transport*">
    <h2><dfn>RTCQuicTransport</dfn> Interface</h2>
    <p>The <code>RTCQuicTransport</code> includes information relating
    to QUIC transport.</p>
    <section id="rtcquictransport-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCQuicTransport</a></code> instance is associated to
      one or more <code><a>RTCQuicStream</a></code> instances.</p>
      <p class="note">The QUIC API presented in this and the subsequent
      section represents a preliminary proposal based on work-in-progress
      within the IETF QUIC WG. Since the QUIC protocol specification is still
      in its early stages, both the protocol and API are likely to
      change significantly going forward (such as changes to support
      uni-directional streams).</p>
    </section>
    <section id="rtcquictransport-operation*">
      <h3>Operation</h3>
      <p>The QUIC transport protocol is described in [[!QUIC-TRANSPORT]].
      A <code><a>RTCQuicTransport</a></code> instance is constructed
      using an <code><a>RTCIceTransport</a></code> and a sequence of
      <code><a>RTCCertificate</a></code> objects.
      An <code><a>RTCQuicTransport</a></code> object in the <code>closed</code> or
      <code>failed</code> states can be garbage-collected when it is no longer
      referenced.</p>
      <p>The QUIC negotiation occurs between transport endpoints determined via ICE.
      Approaches to multiplexing of QUIC with STUN, TURN, DTLS, RTP and RTCP
      are described in [[QUIC-MULT]].</p>
      <p>If an attempt is made to construct a <code><a>RTCQuicTransport</a></code>
      instance from an <code><a>RTCIceTransport</a></code> in the <code>closed</code>
      state, <a>throw</a> an <code>InvalidStateError</code>.
      If <code>certificates</code> is non-empty,
      check that the <code>expires</code> attribute of each
      <code><a>RTCCertificate</a></code> object is in the future.
      If a certificate has expired, <a>throw</a> an <code>InvalidParameter</code>;
      otherwise, store the certificates.</p>
      <p>A newly constructed <code><a>RTCQuicTransport</a></code> <em class="rfc2119"
      title="MUST">MUST</em> listen and respond to incoming QUIC packets before
      <code>start()</code> is called. However, to complete the negotiation it is
      necessary to verify the remote fingerprint, which is an attribute of the
      <code><var>remoteParameters</var></code> argument passed to <code>start()</code>.
      To verify the remote fingerprint, compute the fingerprint <var>value</var> for
      the selected remote certificate using the signature digest algorithm, and compare
      it against <code><var>remoteParameters</var>.fingerprints</code>. If the selected
      remote certificate <code>RTCDtlsFingerprint.value</code> matches
      <code><var>remoteParameters</var>.fingerprints[j].value</code> and
      <code>RTCDtlsFingerprint.algorithm</code> matches
      <code><var>remoteParameters</var>.fingerprints[j].algorithm</code> for any value of
      <var>j</var>, the remote fingerprint is verified. After the QUIC handshake exchange
      completes (but before the remote fingerprint is verified) incoming media packets
      may be received. A modest buffer <em class="rfc2119" title="MUST">MUST</em> be
      provided to avoid loss of media prior to remote fingerprint validation (which can
      begin after <code>start()</code> is called).</p>
    </section>
    <section id="rtcquictransport-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Constructor (RTCIceTransport transport, sequence&lt;RTCCertificate&gt; certificates), Exposed=Window]
interface RTCQuicTransport : RTCStatsProvider {
    readonly        attribute RTCIceTransport          transport;
    readonly        attribute RTCQuicTransportState    state;
    RTCQuicParameters     getLocalParameters ();
    RTCQuicParameters?    getRemoteParameters ();
    sequence&lt;RTCCertificate&gt; getCertificates ();
    sequence&lt;ArrayBuffer&gt; getRemoteCertificates ();
    void                  start (RTCQuicParameters remoteParameters);
    void                  stop ();
    RTCQuicStream         createStream ();
                    attribute EventHandler             onstatechange;
                    attribute EventHandler             onerror;
                    attribute EventHandler             onstream;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "constructors">
            <dt><code><a>RTCQuicTransport</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCIceTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">certificates</td>
                    <td class="prmType">
                    <code>sequence</code>&lt;<code><a>RTCCertificate</a></code>&gt;</td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "attributes">
            <dt><dfn><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceTransport</a></span>, readonly</dt>
            <dd>
              <p>The associated <code><a>RTCIceTransport</a></code> instance.</p>
            </dd>
            <dt><dfn><code>state</code></dfn> of type <span class=
            "idlAttrType"><a>RTCQuicTransportState</a></span>, readonly</dt>
            <dd>
              <p>The current state of the QUIC transport.</p>
            </dd>
            <dt><dfn><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <code><a>RTCQuicTransportState</a></code>
              changes.</p>
            </dd>
            <dt><dfn><code>onerror</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type <code>error</code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired on reception of a QUIC
              error; an implementation <em class="rfc2119" title=
              "SHOULD">SHOULD</em> include QUIC error information in
              <var>error.message</var> (defined in [[!HTML51]] Section 7.1.3.8.2).</p>
            </dd>
            <dt><dfn><code>onstream</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type <code><a>quicstream</a></code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired on when a remote
              <code><a>RTCQuicStream</a></code> is created.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "methods">
            <dt><code>getLocalParameters</code></dt>
            <dd>
              <p><dfn>getLocalParameters()</dfn> obtains the QUIC parameters of
              the local <code><a>RTCQuicTransport</a></code> upon construction.
              If multiple certificates were provided in the constructor, then
              multiple fingerprints will be returned, one for each certificate.
              <code>getLocalParameters().role</code> always returns the default
              role of a newly constructed <code><a>RTCQuicTransport</a></code>;
              for a browser this will be <code>auto</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicParameters</a></code>
              </div>
            </dd>
            <dt><code>getRemoteParameters</code></dt>
            <dd>
              <p><dfn>getRemoteParameters()</dfn> obtains
              the remote QUIC parameters passed in the
              <code>start()</code> method. Prior to calling
              <code>start()</code>, null is returned.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicParameters</a></code>, nullable
              </div>
            </dd>
            <dt><code>getCertificates</code></dt>
            <dd>
              <p><dfn>getCertificates()</dfn> returns the certificates provided in
              the constructor.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;RTCCertificate&gt;</code>
              </div>
            </dd>
            <dt><code>getRemoteCertificates</code></dt>
            <dd>
              <p><dfn>getRemoteCertificates()</dfn> returns the certificate chain in use by the remote side, with each
              certificate encoded in binary Distinguished Encoding Rules (DER) [[!X690]].
              <code><a>getRemoteCertificates()</a></code> returns an empty list prior to
              selection of the remote certificate, which is completed once
              <code><a>RTCQuicTransportState</a></code> transitions to
              <code>connected</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;ArrayBuffer&gt;</code>
              </div>
            </dd>
            <dt><dfn><code>start</code></dfn></dt>
            <dd>
              <p>Start QUIC transport negotiation with the parameters of the remote QUIC
              transport, including verification of the remote fingerprint.
              Only a single QUIC transport can be multiplexed over an ICE transport.
              Therefore if a <code><a>RTCQuicTransport</a></code> object
              <var>quicTransportB</var> is constructed with an
              <code><a>RTCIceTransport</a></code> object <var>iceTransport</var>
              previously used to construct another <code><a>RTCQuicTransport</a></code>
              object <var>quicTransportA</var>, then if
              <code>quicTransportB.start()</code> is called prior to having called
              <code>quicTransportA.stop()</code>, then <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <p>If <code>start</code> is called after a previous <code>start</code>
              call, or if <code>state</code> is <code>closed</code>, <a>throw</a>
              an <code>InvalidStateError</code>.</p>
              <p>If all of the values of
              <code><var>remoteParameters</var>.fingerprints[<var>j</var>].algorithm</code>
              are unsupported, where <var>j</var> goes from 0 to the number of fingerprints,
              <a>throw</a> a <code>NotSupportedError</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">remoteParameters</td>
                    <td class="prmType"><code><a>RTCQuicParameters</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>stop</code></dfn></dt>
            <dd>
              <p>Stops and closes the <code><a>RTCQuicTransport</a></code> object.
              Calling <code>stop()</code> when <code>state</code> is <code>closed</code>
              has no effect.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
           <dt><dfn><code>createStream</code></dfn></dt>
            <dd>
              <p>Creates an <code><a>RTCQuicStream</a></code> object.
              Since [[QUIC-TRANSPORT]] only defines reliable QUIC streams,
              <code>createStream</code> only supports creation of reliable
              streams.</p>
              <p>When <code>createStream</code> is called, the user agent MUST run the
              following steps:</p>
              <ol>
                <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>
                on which <code>createStream</code> is invoked.</li>
                <li>If <code><var>transport</var>.state</code> is <code>closed</code>
                <a>throw</a> an <code>InvalidStateError</code>.</li>
                <li>Let <var>parameters</var> be the first argument.</li>
               <li>
                  <p>Let <var>stream</var> be a newly created
                  <code><a>RTCQuicStream</a></code> object.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\QuicStreamState]]</dfn> internal
                  slot initialized to <code>new</code>.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\Readable]]</dfn> internal
                  slot initialized to <code>false</code>.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\Writeable]]</dfn> internal
                  slot initialized to <code>false</code>.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\MaxWriteBufferedAmount]]</dfn> internal
                  slot initialized to the maximum write buffer size.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\MaxReadBufferedAmount]]</dfn> internal
                  slot initialized to the maximum read buffer size.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\TargetReadBufferedAmount]]</dfn> internal
                  slot initialized to the maximum read buffer size.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\WriteBufferedAmount]]</dfn> internal
                  slot initialized to zero.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> have a <dfn>[[\ReadBufferedAmount]]</dfn> internal
                  slot initialized to zero.</p>
                </li>
                <li>
                  <p>Return <var>stream</var> and continue the following steps
                  in the background.</p>
                </li>
                <li>
                  <p>Create <var>stream</var>'s associated underlying data
                  transport.</p>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicStream</a></code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcquicparameters*">
      <h3><dfn>RTCQuicParameters</dfn> Dictionary</h3>
      <p>The <code>RTCQuicParameters</code> dictionary includes information
      relating to QUIC configuration.</p>
      <div>
        <pre class="idl">dictionary RTCQuicParameters {
             RTCQuicRole                  role = "auto";
             sequence&lt;RTCDtlsFingerprint&gt; fingerprints;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCQuicParameters</a> Members</h2>
          <dl data-link-for="RTCQuicParameters" data-dfn-for="RTCQuicParameters" class=
          "dictionary-members">
            <dt><dfn><code>role</code></dfn> of type <span class=
            "idlMemberType"><a>RTCQuicRole</a></span>, defaulting to
            <code>"auto"</code></dt>
            <dd>
              <p>The QUIC role, with a default of <code>auto</code>.</p>
            </dd>
            <dt><dfn><code>fingerprints</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCDtlsFingerprint</a>&gt;</span></dt>
            <dd>
              <p>Sequence of fingerprints, one fingerprint for each certificate.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3><dfn>RTCQuicStreamEvent</dfn></h3>
      <p>The <code><a>quicstream</a></code> event uses the
      <code><a>RTCQuicStreamEvent</a></code> interface.</p>
      <p>Firing a <code><a>quicstream</a></code> event named <var>e</var> with a
      <code><a>RTCQuicStream</a></code> <var>stream</var> means that an event with the
      name <var>e</var>, which does not bubble (except where otherwise stated) and is not
      cancelable (except where otherwise stated), and which uses the
      <code><a>RTCQuicStreamEvent</a></code> interface with the <code>stream</code>
      attribute set to <var>stream</var>, MUST be created and dispatched at the given target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCQuicStreamEventInit eventInitDict), Exposed=Window]
interface RTCQuicStreamEvent : Event {
    readonly        attribute RTCQuicStream stream;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCQuicStreamEvent" data-dfn-for="RTCQuicStreamEvent"
          class="constructors">
            <dt><code>RTCQuicStreamEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code><a>RTCQuicStreamEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicStreamEvent" data-dfn-for="RTCQuicStreamEvent"
          class="attributes">
            <dt><code>stream</code> of type <span class=
            "idlAttrType"><a>RTCQuicStream</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstreamevent-stream"><code>stream</code></dfn>
              attribute represents the <code><a>RTCQuicStream</a></code> object
              associated with the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
          <p>The <dfn><code>RTCQuicStreamEventInit</code></dfn> dictionary includes
          information on the configuration of the QUIC stream.</p>
        <pre class="idl">dictionary RTCQuicStreamEventInit : EventInit {
             RTCQuicStream stream;
};</pre>
        <section>
          <h2>Dictionary RTCQuicStreamEventInit Members</h2>
          <dl data-link-for="RTCQuicStreamEventInit" data-dfn-for=
          "RTCQuicStreamEventInit" class="dictionary-members">
            <dt><dfn><code>stream</code></dfn> of type <span class=
            "idlMemberType"><a>RTCQuicStream</a></span></dt>
            <dd>
              <p>The <code><a>RTCQuicStream</a></code> object associated with the
              event.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcquicrole*">
      <h3><dfn>RTCQuicRole</dfn> Enum</h3>
      <p><code>RTCQuicRole</code> indicates the role of the QUIC
      transport.</p>
      <div>
        <pre class="idl">enum RTCQuicRole {
    "auto",
    "client",
    "server"
};</pre>
        <table data-link-for="RTCQuicRole" data-dfn-for="RTCQuicRole" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.auto">auto</code></dfn></td>
              <td>
                <p>The QUIC role is determined based on the resolved ICE role:
                the ICE <code>controlled</code> role acts as the QUIC client and
                the ICE <code>controlling</code> role acts as the QUIC server.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.client">client</code></dfn></td>
              <td>
                <p>The QUIC client role.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.server">server</code></dfn></td>
              <td>
                <p>The QUIC server role.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcquicroleinfo">
      <h3>QUIC role determination</h3>
      <p>To diagnose QUIC role issues, an application may wish to determine
      the desired and actual QUIC role of an <code><a>RTCQuicTransport</a></code>.
      For a browser implementing ORTC, a <code><a>RTCQuicTransport</a></code>
      object assumes a QUIC role of <code>auto</code> upon construction.
      This implies that the QUIC role is determined by the ICE role.  Since
      <code>getLocalParameters().role</code> always returns the role assigned
      to an <code><a>RTCQuicTransport</a></code> object upon construction
      (<code>auto</code> for a browser), the <code>getLocalParameters</code>
      method cannot be used to determine the desired or actual role of an
      <code><a>RTCQuicTransport</a></code>.</p>
      <p>An application can determine the
      desired role of an <code><a>RTCQuicTransport</a></code> from the value of
      <code><var>remoteParameters</var>.role</code> passed to
      <code><a>RTCQuicTransport</a>.start(<var>remoteParameters</var>)</code>.
      If <code><var>remoteParameters</var>.role</code> is <code>server</code>
      then the desired role of the <code><a>RTCQuicTransport</a></code>
      is <code>client</code>. If <code><var>remoteParameters</var>.role</code>
      is <code>client</code> then the desired role of the
      <code><a>RTCQuicTransport</a></code> is <code>server</code>.</p>
      <p>The <code>RTCQuicTransport.transport.onstatechange</code> EventHandler
      can be used to determine whether an <code><a>RTCQuicTransport</a></code>
      transitions to the desired role. When
      <code><a>RTCQuicTransport</a>.transport.state</code> transitions to
      <code>connected</code>, if <code><a>RTCQuicTransport</a>.transport.role</code>
      is <code>controlled</code> then the role of the
      <code><a>RTCQuicTransport</a></code> is <code>client</code>.
      If <code><a>RTCQuicTransport</a>.transport.role</code>
      is <code>controlling</code> then the role of the
      <code><a>RTCQuicTransport</a></code> is <code>server</code>.</p>
    </section>
    <section id="rtcquictransportstate*">
      <h3><dfn>RTCQuicTransportState</dfn> Enum</h3>
      <p><code>RTCQuicTransportState</code> indicates the state of the QUIC
      transport.</p>
      <div>
        <pre class="idl">enum RTCQuicTransportState {
    "new",
    "connecting",
    "connected",
    "closed",
    "failed"
};</pre>
        <table data-link-for="RTCQuicTransportState" data-dfn-for="RTCQuicTransportState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicTransportState.new">new</code></dfn></td>
              <td>
                <p>The <code><a>RTCQuicTransport</a></code> object has been created and
                has not started negotiating yet.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.connecting">connecting</code></dfn></td>
              <td>
                <p>QUIC is in the process of negotiating a secure connection and
                verifying the remote fingerprint. Once a secure connection is negotiated
                (but prior to verification of the remote fingerprint, enabled by calling
                <code>start()</code>), incoming data can flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.connected">connected</code></dfn></td>
              <td>
                <p>QUIC has completed negotiation of a secure connection and verified the
                remote fingerprint. Outgoing data and media can now flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.closed">closed</code></dfn></td>
              <td>
                <p>The QUIC connection has been closed intentionally via a call to
                <code>stop()</code> or receipt of a close_notify alert. Calling
                <code>transport.stop()</code> will also result in a transition to the
                <code>closed</code> state.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.failed">failed</code></dfn></td>
              <td>
                <p>The QUIC connection has been closed as the result of an error (such as
                receipt of an error alert or a failure to validate the remote
                fingerprint).</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
  </section>
  <section id="quicstream*">
    <h2><dfn>RTCQuicStream</dfn> Interface</h2>
    <p>The <code>RTCQuicStream</code> includes information relating
    to a QUIC stream.</p>
    <section id="rtcquicstream-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCQuicStream</a></code> instance is associated to
      an <code><a>RTCQuicTransport</a></code> instance.</p>
    </section>
    <section id="rtcquicstream-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCQuicStream</a></code> instance is constructed
      using the <code><a>RTCQuicTransport</a>.createStream</code> method.</p>
    </section>
    <section id="rtcquicstream-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Exposed=Window ]
interface RTCQuicStream {
    readonly        attribute RTCQuicTransport    transport;
    readonly        attribute RTCQuicStreamState  state;
    readonly        attribute unsigned long       readBufferedAmount;
    readonly        attribute unsigned long       maxReadBufferedAmount;
    readonly        attribute unsigned long       targetReadBufferedAmount;
    readonly        attribute unsigned long       writeBufferedAmount;
    readonly        attribute unsigned long       maxWriteBufferedAmount;
    long                  readInto (Uint8Array data);
    void                  write (Uint8Array data);
    void                  finish ();
    void                  reset ();
    Promise&lt;void&gt;   waitForReadable(unsigned long amount);
    Promise&lt;void&gt;   waitForWritable(unsigned long amount, optional unsigned long targetWriteBufferedAmount);
    void                  setTargetReadBufferedAmount(unsigned long amount);
                    attribute EventHandler        onstatechange;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicStream" data-dfn-for="RTCQuicStream" class=
          "attributes">
            <dt><dfn><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCQuicTransport</a></span>, readonly</dt>
            <dd>
              <p>The readonly attribute referring to the related <code><a>RTCQuicTransport</a></code> object.</p>
            </dd>
            <dt><code>state</code> of type <span class=
            "idlAttrType"><a>RTCQuicStreamState</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstream-state"><code>state</code></dfn>
              attribute represents the state of the <a>RTCQuicStream</a> object.
              On getting it <em class="rfc2119" title="MUST">MUST</em> return
              the value of the <code><a>RTCQuicStream</a></code>'s
              <a>[[\QuicStreamState]]</a> internal slot.</p>
            </dd>
            <dt><dfn><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
             <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <code><a>RTCQuicStreamState</a></code>
              changes.</p>
            </dd>
            <dt><code>readBufferedAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstream-readbufferedamount"><code>readBufferedAmount</code></dfn>
              attribute represents the number of bytes buffered for access by
              <code>readInto</code> but that, as of the last time the event loop
              started executing a task, had not yet been read. This does not include
              framing overhead incurred by the protocol, or buffers associated with
              the network hardware. On getting, it <em class="rfc2119" title="MUST">MUST</em>
              return the value of the <code><a>RTCQuicStream</a></code>'s
              <a>[[\ReadBufferedAmount]]</a> internal slot.
              If the <code><a>RTCQuicStream</a></code> is in the <code>closed</code> state,
              this attribute's value will only decrease with each call to the
              <code>readInto</code> method (the attribute does not reset to zero once the
              <code><a>RTCQuicStream</a></code> closes).</p>
            </dd>
            <dt><code>maxReadBufferedAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstream-maxreadbufferedamount"><code>maxReadBufferedAmount</code></dfn>
              attribute represents the maximum number of bytes that the implementation allows
              to be buffered for access by <code>readInto</code>. On getting, it
              <em class="rfc2119" title="MUST">MUST</em> return the value of the
              <code><a>RTCQuicStream</a></code>'s <a>[[\MaxReadBufferedAmount]]</a> internal slot.</p>
            </dd>
            <dt><code>targetReadBufferedAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The
              <dfn id="dom-quicstream-targetreadbufferedamount"><code>targetReadBufferedAmount</code></dfn>
              attribute represents the target number of bytes in the read buffer, which enables control
              of back-pressure on the sender when the target number of bytes is read. On getting,
              it <em class="rfc2119" title="MUST">MUST</em> return the value of the
              <code><a>RTCQuicStream</a></code>'s <a>[[\TargetReadBufferedAmount]]</a> internal slot.</p>
            </dd>
            <dt><code>writeBufferedAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstream-writebufferedamount"><code>writeBufferedAmount</code></dfn>
              attribute represents the number of bytes of application data
              that have been queued using <code>write</code> but that, as of the last
              time the event loop started executing a task, had not yet been transmitted
              to the network. This includes any data sent during the execution of the
              current task, regardless of whether the <a>user agent</a> is able to
              transmit text asynchronously with script execution. This does not
              include framing overhead incurred by the protocol, or buffering done
              by the operating system or network hardware. On getting, it
              <em class="rfc2119" title="MUST">MUST</em> return the value of the
              <code><a>RTCQuicStream</a></code>'s <a>[[\WriteBufferedAmount]]</a> internal slot.
              If the <code><a>RTCQuicStream</a></code> is in the <code>closed</code>
              state, this attribute's value will only increase with each call to the
              <code>write</code> method (the attribute does not reset to zero once the
              <code><a>RTCQuicStream</a></code> closes).</p>
            </dd>
            <dt><code>maxWriteBufferedAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-quicstream-maxwritebufferedamount"><code>maxWriteBufferedAmount</code></dfn>
              attribute represents the maximum number of bytes that the implementation allows
              to be buffered by <code>write</code>. On getting, it <em class="rfc2119" title="MUST">MUST</em>
              return the value of the <code><a>RTCQuicStream</a></code>'s
              <a>[[\MaxWriteBufferedAmount]]</a> internal slot.</p>
            </dd>
          </dl>
       </section>
       <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCQuicStream" data-dfn-for="RTCQuicStream" class=
          "methods">
            <dt><dfn><code>readInto</code></dfn></dt>
            <dd>
              <p>Reads from <code><a>RTCQuicStream</a></code> into the buffer specified
              by the first argument and returns the number of bytes read; a negative
              number indicates end-of-file. If there is no data to be read then
              <code>readInto</code> returns zero. When the <code>readInto</code>
              method is called, the user agent
              <em class="rfc2119" title="MUST">MUST</em> run the following steps:</p>
              <ol>
               <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code> object
               on which <code>readInto</code> is invoked.</li>
               <li>If <var>stream</var>'s <a>[[\Readable]]</a> slot is <code>false</code>,
               <a>throw</a> an <code>InvalidStateError</code>, then abort these steps.</li>
               <li>Let <var>data</var> be the first argument.</li>
               <li>If the read buffer is empty and end-of-file has been encountered, return
               a negative number, set <var>stream</var>'s <a>[[\Readable]]</a> slot to
               <code>false</code> and abort these steps.</li>
               <li>Transfer data from the read buffer into <var>data</var>.</li>
               <li>Decrease the value of <var>stream</var>'s <a>[[\ReadBufferedAmount]]</a>
               slot by the length of <var>data</var> in bytes.</li>
               <li>Return the length of <var>data</var> in bytes.</li>
              </ol>
              <table class="parameters">
               <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>Uint8Array</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>long</code>
              </div>
            </dd>
            <dt><dfn><code>write</code></dfn></dt>
            <dd>
              <p>When the <code>write</code> method is called, the <a>user agent</a>
              MUST run the following steps:</p>
              <ol>
               <li>Let <var>data</var> be the first argument.</li>
               <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code>
               object on which <var>data</var> is to be sent.</li>
               <li>If <var>stream</var>'s <a>[[\Writeable]]</a> slot is <code>false</code>,
               <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</li>
               <li>If the length of <var>data</var> added to <a>[[\WriteBufferedAmount]]</a>
               exceeds <a>[[\MaxWriteBufferedAmount]]</a>, <a>throw</a> an
               <code>OperationError</code> and abort these steps.</li>
               <li>Increase the value of <var>stream</var>'s
               <a>[[\WriteBufferedAmount]]</a> slot by the length of
               <var>data</var> in bytes.</li>
               <li>Queue <var>data</var> for transmission on <var>stream</var>'s
               underlying data transport.
               <div class="note">The actual transmission of data occurs in
               parallel. If sending data leads to a QUIC-level error, the
               application will be notified asynchronously through the
               <code><a>RTCQuicTransport</a></code>'s <code><a>onerror</a></code>
               EventHandler.</div></li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>Uint8Array</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>finish</code></dfn></dt>
            <dd>
              <p>Intitiates the closing procedure for the local
              <code><a>RTCQuicStream</a></code> to stop writing. It may be called
              regardless of whether the <code><a>RTCQuicStream</a></code> object
              was created by the local or remote peer. When the <code>finish()</code>
              method is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code> object
                which is about to be closed.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> is <code>new</code>,
                set <var>stream</var>'s  <a>[[\QuicStreamState]]</a> to <code>closed</code>,
                and abort these steps.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> is <code>closed</code>,
                then abort these steps.</li>
                <li>Set <var>stream</var>'s <a>[[\Writeable]]</a> slot to <code>false</code>.</li>
                <li> If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> is <code>closing</code> and
                the stream has received a STREAM frame with the FIN bit set, run the following steps:
                  <ol>
                    <li>Set <var>stream</var>'s <a>[[\Readable]]</a> slot to
                    <code>false</code>.</li>
                    <li>Set <var>stream</var>'s <a>[[\QuicStreamState]]</a> slot to
                    <code>closed</code>.</li>
                  </ol>
                </li>
                <li>Else, run the following step:
                  <ol>
                    <li>Set <var>stream</var>'s <a>[[\QuicStreamState]]</a> slot to
                    <code>closing</code>.</li>
                  </ol>
                </li>
                <li>If the closing procedure has not started yet, start it by sending a STREAM
                frame with the FIN bit set.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>reset</code></dfn></dt>
            <dd>
              <p>Resets the <code><a>RTCQuicStream</a></code>. It may be called
              regardless of whether the <code><a>RTCQuicStream</a></code> object
              was created by the local or remote peer. When the <code>reset()</code>
              method is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code> object
                which is about to be reset.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> is <code>new</code>,
                set <var>stream</var>'s  <a>[[\QuicStreamState]]</a> to <code>closed</code>,
                and abort these steps.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> slot is <code>closed</code>,
                then abort these steps.</li>
                <li>If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> slot is <code>closing</code>
                and the stream has received a RST_STREAM frame, then abort these steps.
                <li>Set <var>stream</var>'s <a>[[\Writeable]]</a> and <a>[[\Readable]]</a>
                slots to <code>false</code>.</li>
                <li> If <var>stream</var>'s  <a>[[\QuicStreamState]]</a> is <code>closing</code> and
                the stream has received a STREAM frame with the FIN bit set, run the following step:
                  <ol>
                    <li>Set <var>stream</var>'s <a>[[\QuicStreamState]]</a> slot to
                    <code>closed</code>.</li>
                  </ol>
                </li>
                <li>Else, run the following step:
                  <ol>
                    <li>Set <var>stream</var>'s <a>[[\QuicStreamState]]</a> slot to
                    <code>closing</code>.</li>
                  </ol>
                </li>
                <li>If the closing procedure has not started yet, start it by sending a RST_STREAM
                frame.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
           <dt><dfn><code>waitForReadable</code></dfn></dt>
            <dd>
              <p><code>waitForReadable</code> resolves the promise
              when the data queued in the read buffer increases above
              the amount provided as an argument. If <code>waitForReadable</code>
              is called multiple times, multiple promises could be resolved when
              the read buffer increases above the amount provided for each promise.
              Promises won't be rejected, and a promise might never be resolved
              in the case that the read buffer never increases above the amount
              specified. When the <code>waitForReadable</code> method is called,
              the <a>user agent</a> MUST run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code>
                on which <code>waitForReadable</code> is invoked.</li>
                <li>Let <var>p</var> be a new promise.</li>
                <li>If <var>stream</var>'s <a>[[\Readable]]</a> slot is
                <code>false</code>, <a>reject</a> <var>p</var> with a
                newly created <code>InvalidStateError</code> and abort
                these steps.</li>
                <li>Let <var>amount</var> be the first argument.</li>
                <li>If <var>amount</var> is larger than the value of
                <var>stream</var>'s <a>[[\TargetReadBufferedAmount]]</a> slot,
                <a>reject</a> <var>p</var> with a newly created
                <code>OperationError</code>.</li>
                <li>When <a>[[\ReadBufferedAmount]]</a> increases from below the
                value of <var>amount</var> to greater than or equal to it,
                <a>resolve</a> <var>p</var> with <code>undefined</code>.</li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">amount</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
            <dt><dfn><code>waitForWritable</code></dfn></dt>
            <dd>
              <p><code>waitForWritable</code> resolves the promise when
              the data queued in the write buffer falls below a threshold
              computed from the arguments to the method. If <code>waitForWritable</code>
              is called multiple times, multiple promises could be resolved when the
              write buffer falls below the threshold for each promise. Promises won't
              be rejected, and a promise might never be resolved in the case that the
              write buffer never falls below the threshold.
              When the <code>waitForWritable</code> method is called,
              the <a>user agent</a> MUST run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code>
                object on which <code>waitForWritable</code> was invoked.</li>
                <li>Let <var>p</var> be a new promise.</li>
                <li>If <var>stream</var>'s <a>[[\Writeable]]</a> slot is
                <code>false</code>, <a>reject</a> <var>p</var> with a
                newly created <code>InvalidStateError</code> and abort
                these steps.</li>
                <li>Let <var>amount</var> be the first argument.</li>
                <li>Let <var>target</var> be the second argument, if provided.
                If the second argument is not provided, let <var>target</var>
                be the value of <var>stream</var>'s <a>[[\MaxWriteBufferedAmount]]</a>
                slot.</li>
                <li>If <var>amount</var> is larger than <var>target</var> then
                <a>reject</a> <var>p</var> with a newly created
                <code>OperationError</code>.</li>
                <li>Let <var>threshold</var> be <var>target</var> minus <var>amount</var>.</li>
                <li>When <var>stream</var>'s <a>[[\WriteBufferedAmount]]</a> slot decreases
                from above <var>threshold</var> to less than or equal to it,
                <a>resolve</a> <var>p</var> with <code>undefined</code>.</li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">amount</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">targetWriteBufferedAmount</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
            <dt><dfn><code>setTargetReadBufferedAmount</code></dfn></dt>
            <dd>
              <p><code>setTargetReadBufferedAmount</code> sets the value
              of the <code><a>RTCQuicStream</a></code>'s <a>[[\TargetReadBufferedAmount]]</a>
              internal slot, which represents the target number of bytes in the
              <code><a>RTCQuicStream</a></code>'s receive buffer.
              When the <code>setTargetReadBufferedAmount</code> method is called,
              the <a>user agent</a> MUST run the following steps:</p>
              <ol>
               <li>Let <var>stream</var> be the <code><a>RTCQuicStream</a></code>
               on which <code>setTargetReadBufferedAmount</code> is invoked.</li>
               <li>Let <var>amount</var> be the first argument.</li>
               <li>If <var>amount</var> is greater than the <var>stream</var>'s
               <a>[[\MaxReadBufferedAmount]]</a> slot, <a>throw</a> an
               <code>OperationError</code> and abort these steps.</li>
               <li>Set <var>stream</var>'s <a>[[\TargetReadBufferedAmount]]</a> slot to
               <var>amount</var>.</li>
               <li>If <var>amount</var> is less than <var>stream</var>'s
               <a>[[\ReadBufferedAmount]]</a> slot, apply backpressure
               until <a>[[\ReadBufferedAmount]]</a> becomes less than
               or equal to <var>amount</var>.</li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">amount</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
        </dl>
      </section>
      </div>
    </section>
    <section id="rtcquicstreamstate*">
      <h2><dfn>RTCQuicStreamState</dfn> Enum</h2>
      <p>The <code>RTCQuicStreamState</code> provides information
      on the state of the QUIC stream.</p>
      <div>
        <pre class="idl">enum RTCQuicStreamState {
    "new",
    "opening",
    "open",
    "closing",
    "closed"
};</pre>
       <table data-link-for="RTCQuicStreamState" data-dfn-for="RTCQuicStreamState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicStreamState.new">new</code></dfn></td>
              <td>
                <p>The <a>user agent</a> has not yet attempted to
                establish the underlying stream transport.  This is
                the initial state of an <code><a>RTCQuicStream</a></code>
                object, corresponding to the "idle" state in
                [[QUIC-TRANSPORT]] Section 10.2.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicStreamState.opening">opening</code></dfn></td>
              <td>
                <p>The underlying QUIC stream has queued a STREAM frame for
                transmission, but has not yet received an acknowledgement.
                On transitioning to the <code>opening</code> state, the
                <a>[[\Writeable]]</a> slot is set to <code>true</code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicStreamState.open">open</code></dfn></td>
              <td>
                <p>The underlying QUIC stream has received a STREAM, MAX_STREAM_DATA or
                STREAM_BLOCKED frame, or has sent a STREAM frame and received an acknowledgement,
                as described in [[QUIC-TRANSPORT]] Section 10.2. This is the initial state of an
                <code><a>RTCQuicStream</a></code> object dispatched as a part of an
                <code>RTCQuicStreamEvent</code>. On transitioning to the <code>open</code>
                state, the <a>[[\Readable]]</a> and <a>[[\Writeable]]</a> slots are set to
                <code>true</code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicStreamState.closing">closing</code></dfn></td>
              <td>
                <p>The procedure to close down the QUIC stream has started.
                This can happen in multiple ways:</p>
                  <ol>
                     <li>A RST_STREAM frame or STREAM frame with the FIN flag
                     set has not yet been received and the <code>reset</code>
                     method has been called. This causes a RST_STREAM frame to be
                     queued for transmission, the read and write buffers to be
                     cleared and the <a>[[\Readable]]</a> and <a>[[\Writeable]]</a>
                     slots are set to <code>false</code>.</li>
                     <li>A RST_STREAM frame or STREAM frame with the FIN flag
                     set has not yet been received and the <code>finish</code>
                     method has been called. This causes a STREAM frame with the
                     FIN flag set to be queued for transmission.</li>
                     <li> The QUIC stream has received a RST_STREAM frame. This causes
                     the read and write buffers to be cleared and the <a>[[\Readable]]</a>
                     and <a>[[\Writeable]]</a> slots are set to <code>false</code>.</li>
                     <li> The QUIC stream has received STREAM frame with the FIN flag set.</li>
                  </ol>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicStreamState.closed">closed</code></dfn></td>
              <td>
                <p>The QUIC stream has been closed or could not be established.
                A RST_STREAM frame has been received and a RST_STREAM frame
                has been queued for transmission in response or a FIN flag
                in a STREAM frame has been received and a FIN flag in a
                STREAM frame has been queued for transmission in response.
                Alternatively:</p>
                  <ol>
                     <li>A RST_STREAM frame has been sent and a RST_STREAM
                     frame or a STREAM frame with the FIN flag set has been
                     received, OR</li>
                     <li>A STREAM frame with the FIN flag set has been sent
                     and a RST_STREAM frame has been received, OR</li>
                     <li>A STREAM frame with the FIN flag set has been sent
                     and a STREAM frame with the FIN flag set has been received.
                     </li>
                  </ol>
                <p>On transitioning to the <code>closed</code> state, the
                <a>[[\Readable]]</a> and <a>[[\Writeable]]</a> slots are set to
                <code>false</code>.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <figure>
      <img alt="RTCQuicStreamState transition diagram" src=
      "images/quicstream-state-revised.svg" style="width:50%">
      <figcaption>
        RTCQuicStreamState transition diagram
      </figcaption>
      </figure>
    </section>
  </section>
    <section id="privacy-security">
    <h2>Privacy and Security Considerations</h2>
    <p>This section is non-normative; it specifies no new behaviour, but
    instead summarizes information already present in other parts of the
    specification. The overall security considerations of the
    APIs and protocols used in WebRTC are described in
    [[RTCWEB-SECURITY-ARCH]].</p>
    <section>
      <h2>Impact on same origin policy</h2>
      <p>The QUIC API enables data to be communicated between
      browsers and other devices, including other browsers.</p>
      <p>This means that data can be shared between applications
      running in different browsers, or between an application running in the
      same browser and something that is not a browser.  This is an extension
      to the Web model which has had barriers against sending data
      between entities with different origins.</p>
      <p>This specification provides no user prompts or chrome indicators
      for communication; it assumes that once the Web page has been allowed to
      access data, it is free to share that data with other entities as it
      chooses. Peer-to-peer exchanges of data via QUIC can therefore
      occur without any user explicit consent or involvement.</p>
    </section>
    <section>
      <h2>Impact on local network</h2>
      <p>Since the browser is an active platform executing in a trusted network
      environment (inside the firewall), it is important to limit the damage
      that the browser can do to other elements on the local network, and it is
      important to protect data from interception, manipulation and
      modification by untrusted participants.</p>
      <p>Mitigations include:</p>
      <ul>
        <li>An UA will always request permission from the correspondent UA to
        communicate using ICE. This ensures that the UA can only send to
        partners who you have shared credentials with.</li>
        <li>An UA will always request ongoing permission to continue sending
        using ICE consent [[!RFC7675]]. This enables a receiver to withdraw
        consent to receive.</li>
        <li>An UA will always encrypt data, with strong per-session keying.</li>
        <li>An UA will always use congestion control. This ensures that QUIC
        cannot be used to flood the network.</li>
      </ul>
      <p>These measures are specified in the relevant IETF documents.</p>
    </section>
    <section>
      <h2>Confidentiality of Communications</h2>
      <p>The fact that communication is taking place cannot be hidden from
      adversaries that can observe the network, so this has to be regarded as
      public information.</p>
      <p>Since the QUIC protocol utilizes a cryptographic negotiation based on
      TLS 1.3 [[TLS13]] in order to encrypt communications, it provides confidentiality.</p>
    </section>
    <section>
      <h2>Persistent information</h2>
      <p>Utilizing the <code>generateCertificate</code> API in [[!WEBRTC]], it is possible to
      generate and store certificates that can subsequently be reused in constructing
      <code><a>RTCQuicTransport</a></code> objects.  These persistent certificates
      can therefore be used to identify a user.</p>
    </section>
  </section>
  <section class="informative">
    <h2>Event summary</h2>
    <p>The following events fire on <code><a>RTCQuicTransport</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>ErrorEvent</a></code></td>
          <td>The <code><a>RTCQuicTransport</a></code> object has encountered an error.</td>
        </tr>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCQuicTransportState</a></code> changed.</td>
        </tr>
        <tr>
          <td><dfn><code>quicstream</code></dfn></td>
          <td><code><a>RTCQuicStreamEvent</a></code></td>
          <td>A new <code><a>RTCQuicStream</a></code> is dispatched to the script in
          response to the remote peer creating a QUIC stream.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCQuicStream</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCQuicStreamState</a></code> changed.</td>
        </tr>
      </tbody>
    </table>
  </section>
 <section class="informative" id="examples*">
    <h2>Examples</h2>
      <pre class="example highlight">
      </pre>
 </section>
 <section id="change-log*">
    <h2>Change Log</h2>
    <p>This section will be removed before publication.</p>
 </section>
 <section class="appendix">
    <h2>Acknowledgements</h2>
    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan H&aring;kansson, Bernard Aboba and Dominique
    Haza&euml;l-Massieux, for their support. Contributions to this
    specification were provided by Robin Raymond.</p>
    <p>The <code><a>RTCQuicTransport</a></code> and <code><a>RTCQuicStream</a></code> objects
    were initially described in the <a href="https://www.w3.org/community/ortc/">W3C ORTC CG</a>,
    and have been adapted for use in this specification.</p>
 </section>
</body>
</html>
